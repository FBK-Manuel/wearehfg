

# ðŸ“˜ Redux Toolkit (RTK) Documentation

## ðŸ”¹ What is Redux?

Redux is a **state management library** for JavaScript apps. It allows you to store and manage application-wide state (like cart items, user info, theme, etc.) in a **single source of truth (the store)**.

Instead of passing props between components, Redux provides a **global state** that any component can read from or write to.

---

## ðŸ”¹ Why Redux Toolkit (RTK)?

Redux Toolkit simplifies Redux by providing:

* Less boilerplate (no need to write action types manually).
* Built-in `createSlice` for reducers + actions.
* Easy configuration with `configureStore`.
* Better TypeScript support.

---

## ðŸ”¹ Basic Flow of Redux

1. **Store** â†’ Holds the entire app state.
2. **Slice** â†’ Defines a piece of state (e.g., `cart`, `user`) and actions to update it.
3. **Provider** â†’ Makes the store available to all React components.
4. **useDispatch** â†’ Sends actions to modify the store.
5. **useSelector** â†’ Reads data from the store.

---

## ðŸ”¹ Setting Up Redux

### 1. Install

```bash
npm install @reduxjs/toolkit react-redux
```

### 2. Create a Slice

Each slice represents one feature (e.g., `cartSlice.ts`):

```ts
import { createSlice, PayloadAction } from "@reduxjs/toolkit";

interface CartItem {
  id: string;
  name: string;
  price: number;
  quantity: number;
}

interface CartState {
  items: CartItem[];
}

const initialState: CartState = { items: [] };

const cartSlice = createSlice({
  name: "cart",
  initialState,
  reducers: {
    addToCart: (state, action: PayloadAction<CartItem>) => {
      state.items.push(action.payload);
    },
    removeFromCart: (state, action: PayloadAction<string>) => {
      state.items = state.items.filter(item => item.id !== action.payload);
    },
  },
});

export const { addToCart, removeFromCart } = cartSlice.actions;
export default cartSlice.reducer;
```

### 3. Configure Store

```ts
import { configureStore } from "@reduxjs/toolkit";
import cartReducer from "../features/cart/cartSlice";

export const store = configureStore({
  reducer: {
    cart: cartReducer,
  },
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

### 4. Provide Store to App

Wrap your app with `<Provider>`:

```tsx
import { Provider } from "react-redux";
import { store } from "./store/store";

<Provider store={store}>
  <App />
</Provider>
```

---

## ðŸ”¹ Using Redux in Components

### Read State

```tsx
import { useSelector } from "react-redux";
import { RootState } from "../store/store";

const cartItems = useSelector((state: RootState) => state.cart.items);
```

### Dispatch Actions

```tsx
import { useDispatch } from "react-redux";
import { AppDispatch } from "../store/store";
import { addToCart } from "../features/cart/cartSlice";

const dispatch = useDispatch<AppDispatch>();

dispatch(addToCart({ id: "1", name: "Product A", price: 20, quantity: 1 }));
```

---

## ðŸ”¹ Best Practices

* Keep state **normalized** (no deeply nested objects).
* Create separate slices for `user`, `products`, `orders`, `cart`.
* Use **RTK Query** (built into Redux Toolkit) for API requests if you donâ€™t want to manage fetching manually.
* Use TypeScript for type safety (`RootState`, `AppDispatch`).

---

âœ… With this setup, you can manage global state like cart, authentication, and orders across your entire eCommerce web app.

Do you want me to also add an **example folder structure for Redux in eCommerce** (e.g., `features/cart`, `features/user`, `features/products`), so you see how everything should be organized?
